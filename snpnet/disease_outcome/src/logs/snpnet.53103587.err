[/var/spool/slurmd/job53103587/slurm_script 20191022-163851] [start] hostname = sh-116-04.int SLURM_JOBID = 53103587; phenotype = HC326
tmp_dir = /lscratch/ytanigaw/tmp-snpnet_wrapper.sh-20191022-163851-xeooTElDYt
===================config_file===================
#key	val
snpnet_dir	/oak/stanford/groups/mrivas/software/snpnet
mem2bufferSizeDivisionFactor	5
cpu	8
mem	150000
niter	100
genotype_dir	/scratch/users/ytanigaw/tmp/snpnet/geno/array_combined
out_dir_root	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome/out
phenotype_file	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome/phe/phe.tsv
phenotype_name	HC326
family	binomial
covariates	age,sex,Array,PC1,PC2,PC3,PC4
prevIter	35
===================config_file===================
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 3.1.0       ✔ purrr   0.3.1  
✔ tibble  2.0.1       ✔ dplyr   0.8.0.1
✔ tidyr   0.8.3       ✔ stringr 1.4.0  
✔ readr   1.3.1       ✔ forcats 0.4.0  
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: data.table

Attaching package: ‘data.table’

The following objects are masked from ‘package:dplyr’:

    between, first, last

The following object is masked from ‘package:purrr’:

    transpose

Loading required package: glmnet
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:tidyr’:

    expand

Loading required package: foreach

Attaching package: ‘foreach’

The following objects are masked from ‘package:purrr’:

    accumulate, when

Loaded glmnet 2.0-20

Loading required package: survival
Loading snpnet
Extracting number of samples and rownames from train.fam...
Extracting number of variants and colnames from train.bim...
Extracting number of samples and rownames from val.fam...
Extracting number of variants and colnames from val.bim...

 *** caught bus error ***
address 0x7fcfafb91f77, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfa3347000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfd6ad6eec, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfc9f47000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfe3e945a7, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfbe347000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcf8a14d910, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcf97251dac, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcfefea1703, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fcffcc1fb6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd00999dfd3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd01671c43b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd02349a8a3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd030218d0b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd03cf97173, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd049d155db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd056a93a43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd063811eab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd070590313, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd07d30e77b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd08a08cbe3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd096e0b04b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0a3b894b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0b090791b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0bd677709, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0ca3f5b71, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0d7173fd9, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0e3ef2441, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0f0c708a9, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd0fd9eed11, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd10a76d179, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1174eb5e1, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd12425b3cf, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd130fd9837, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd13dd57c9f, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd14aad6107, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd15785456f, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1645d29d7, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd171350e3f, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd17e0cf2a7, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd18ae3f095, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd197bbd4fd, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1a493b965, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1b16b9dcd, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1be438235, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1cb1b669d, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fd1d7f47000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...
Error in dimnames(x) <- dn : 
  length of 'dimnames' [1] not equal to array extent
Calls: snpnet -> KKT.check -> computeProduct -> rownames<-
In addition: There were 25 warnings (use warnings() to see them)
Execution halted
