[/var/spool/slurmd/job53103586/slurm_script 20191022-163747] [start] hostname = sh-116-04.int SLURM_JOBID = 53103586; phenotype = HC188
tmp_dir = /lscratch/ytanigaw/tmp-snpnet_wrapper.sh-20191022-163747-ZMOVntJ46m
===================config_file===================
#key	val
snpnet_dir	/oak/stanford/groups/mrivas/software/snpnet
mem2bufferSizeDivisionFactor	5
cpu	8
mem	150000
niter	100
genotype_dir	/scratch/users/ytanigaw/tmp/snpnet/geno/array_combined
out_dir_root	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome/out
phenotype_file	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome/phe/phe.tsv
phenotype_name	HC188
family	binomial
covariates	age,sex,Array,PC1,PC2,PC3,PC4
prevIter	30
===================config_file===================
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 3.1.0       ✔ purrr   0.3.1  
✔ tibble  2.0.1       ✔ dplyr   0.8.0.1
✔ tidyr   0.8.3       ✔ stringr 1.4.0  
✔ readr   1.3.1       ✔ forcats 0.4.0  
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: data.table

Attaching package: ‘data.table’

The following objects are masked from ‘package:dplyr’:

    between, first, last

The following object is masked from ‘package:purrr’:

    transpose

Loading required package: glmnet
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:tidyr’:

    expand

Loading required package: foreach

Attaching package: ‘foreach’

The following objects are masked from ‘package:purrr’:

    accumulate, when

Loaded glmnet 2.0-20

Loading required package: survival
Loading snpnet
Extracting number of samples and rownames from train.fam...
Extracting number of variants and colnames from train.bim...
Extracting number of samples and rownames from val.fam...
Extracting number of variants and colnames from val.bim...

 *** caught bus error ***
address 0x7f795a556000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7940f13000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f798d713000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7980f5e7a2, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7967f13000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f794da06457, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f793466901c, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7974662091, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7998aa4a03, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79a5822e6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79b25a12d3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79bf31f73b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79cc09dba3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79d8e1c00b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79e5b9a473, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79f29188db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f79ff696d43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a0c4151ab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a19193613, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a25f11a7b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a32c8fee3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a3fa0e34b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a4c78c7b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a5950ac1b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a66289083, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a730074eb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a7fd85953, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a8cb03dbb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7a99882223, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7aa660068b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7ab337eaf3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7ac00fcf5b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7acce7b3c3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7ad9bf982b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7ae6977c93, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7af36f60fb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b00474563, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b0d1f29cb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b19f70e33, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b26cef29b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b33a6d703, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b407ebb6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b4d569fd3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b5a2e843b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b670668a3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b73de4d0b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b80b63173, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b8d8e15db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7b9a65fa43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7ba73ddeab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7bb415c313, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7bc0eda77b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7bcdc58be3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7bda9d704b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7be77554b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7bf44d391b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f7c1ad3ffd9, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...
Error in dimnames(x) <- dn : 
  length of 'dimnames' [1] not equal to array extent
Calls: snpnet -> KKT.check -> computeProduct -> rownames<-
In addition: There were 18 warnings (use warnings() to see them)
Execution halted
