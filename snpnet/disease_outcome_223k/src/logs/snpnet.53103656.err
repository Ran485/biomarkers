[/var/spool/slurmd/job53103656/slurm_script 20191022-163908] [start] hostname = sh-116-04.int SLURM_JOBID = 53103656; phenotype = HC326
tmp_dir = /lscratch/ytanigaw/tmp-snpnet_wrapper.sh-20191022-163908-gc3wRY0QYO
===================config_file===================
#key	val
snpnet_dir	/oak/stanford/groups/mrivas/software/snpnet
mem2bufferSizeDivisionFactor	5
cpu	8
mem	150000
niter	100
genotype_dir	/scratch/users/ytanigaw/tmp/snpnet/geno/array_combined
out_dir_root	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome_223k/out
phenotype_file	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome_223k/phe/phe.tsv
phenotype_name	HC326
family	binomial
covariates	age,sex,Array,PC1,PC2,PC3,PC4
prevIter	28
===================config_file===================
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 3.1.0       ✔ purrr   0.3.1  
✔ tibble  2.0.1       ✔ dplyr   0.8.0.1
✔ tidyr   0.8.3       ✔ stringr 1.4.0  
✔ readr   1.3.1       ✔ forcats 0.4.0  
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: data.table

Attaching package: ‘data.table’

The following objects are masked from ‘package:dplyr’:

    between, first, last

The following object is masked from ‘package:purrr’:

    transpose

Loading required package: glmnet
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:tidyr’:

    expand

Loading required package: foreach

Attaching package: ‘foreach’

The following objects are masked from ‘package:purrr’:

    accumulate, when

Loaded glmnet 2.0-20

Loading required package: survival
Loading snpnet
Extracting number of samples and rownames from train.fam...
Extracting number of variants and colnames from train.bim...
Extracting number of samples and rownames from val.fam...
Extracting number of variants and colnames from val.bim...

 *** caught bus error ***
address 0x7fa185afbf83, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1c8f6b000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1b8c35000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1d4d01000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa192ad78a4, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1abf87be1, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1a0bd212a, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1e0300e39, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1e8b18383, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa1f58967eb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa202614c53, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa20f3930bb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa21c111523, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa228e8f98b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa235c0ddf3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa24298c25b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa24f70a6c3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa25c488b2b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa269206f93, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa275f853fb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa282d03863, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa28fa81ccb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa29c800133, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2a957e59b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2b62fca03, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2c307ae6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2cfdf92d3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2dcb7773b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2e98f5ba3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa2f667400b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3033f2473, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3101708db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa31ceeed43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa329c6d1ab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3369eb613, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa343769a7b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3504e7ee3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa35d26634b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa369fe47b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa376d62c1b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa383ae1083, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa39085f4eb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa39d5dd953, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3aa35bdbb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3b70da223, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3c3e5868b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3d0bd6af3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3dd954f5b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3ea6d33c3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa3f745182b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4041cfc93, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa410f4e0fb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa41dccc563, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa42aa4a9cb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4377c8e33, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa44454729b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4512c5703, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa45e043b6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa46adc1fd3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa477b4043b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4848be8a3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa49163cd0b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa49e3bb173, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4ab1395db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4b7eb7a43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4c4c35eab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4d19b4313, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4de73277b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4eb4b0be3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa4f822f04b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa504fad4b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7fa511d2b91b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...
Error in dimnames(x) <- dn : 
  length of 'dimnames' [1] not equal to array extent
Calls: snpnet -> KKT.check -> computeProduct -> rownames<-
In addition: There were 24 warnings (use warnings() to see them)
Execution halted
