[/var/spool/slurmd/job53103655/slurm_script 20191022-163855] [start] hostname = sh-116-04.int SLURM_JOBID = 53103655; phenotype = HC188
tmp_dir = /lscratch/ytanigaw/tmp-snpnet_wrapper.sh-20191022-163855-7Th7C4wX8k
===================config_file===================
#key	val
snpnet_dir	/oak/stanford/groups/mrivas/software/snpnet
mem2bufferSizeDivisionFactor	5
cpu	8
mem	150000
niter	100
genotype_dir	/scratch/users/ytanigaw/tmp/snpnet/geno/array_combined
out_dir_root	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome_223k/out
phenotype_file	/oak/stanford/groups/mrivas/users/ytanigaw/repos/rivas-lab/public-resources/uk_biobank/biomarkers/snpnet/disease_outcome_223k/phe/phe.tsv
phenotype_name	HC188
family	binomial
covariates	age,sex,Array,PC1,PC2,PC3,PC4
prevIter	24
===================config_file===================
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.2.1 ──
✔ ggplot2 3.1.0       ✔ purrr   0.3.1  
✔ tibble  2.0.1       ✔ dplyr   0.8.0.1
✔ tidyr   0.8.3       ✔ stringr 1.4.0  
✔ readr   1.3.1       ✔ forcats 0.4.0  
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()
Loading required package: data.table

Attaching package: ‘data.table’

The following objects are masked from ‘package:dplyr’:

    between, first, last

The following object is masked from ‘package:purrr’:

    transpose

Loading required package: glmnet
Loading required package: Matrix

Attaching package: ‘Matrix’

The following object is masked from ‘package:tidyr’:

    expand

Loading required package: foreach

Attaching package: ‘foreach’

The following objects are masked from ‘package:purrr’:

    accumulate, when

Loaded glmnet 2.0-20

Loading required package: survival
Loading snpnet
Extracting number of samples and rownames from train.fam...
Extracting number of variants and colnames from train.bim...
Extracting number of samples and rownames from val.fam...
Extracting number of variants and colnames from val.bim...

 *** caught bus error ***
address 0x7f8d911f3000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8dc43b0000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8d77bb0000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8db7bdf340, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8d9ebb0000, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8d845cb494, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8d6b28e750, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8dab2f9ed0, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8dcf741a03, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ddc4bfe6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8de923e2d3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8df5fbc73b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e02d3aba3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e0fab900b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e1c837473, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e295b58db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e36333d43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e430b21ab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e4fe30613, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e5cbaea7b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e6992cee3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e766ab34b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e834297b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e901a7c1b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8e9cf26083, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ea9ca44eb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8eb6a22953, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ec37a0dbb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ed051f223, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8edd29d68b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8eea01baf3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ef6d99f5b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f03b183c3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f1089682b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f1d614c93, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f2a3930fb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f37111563, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f43e8f9cb, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f50c0de33, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f5d98c29b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f6a70a703, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f77488b6b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f84206fd3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f90f8543b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8f9dd038a3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8faaa81d0b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8fb7800173, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8fc457e5db, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8fd12fca43, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8fde07aeab, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8feadf9313, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f8ff7b7777b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90048f5be3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f901167404b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f901e3f24b3, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f902b17091b, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f9037ee0709, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f9044c5eb71, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90519dcfd9, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f905e75b441, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f906b4d98a9, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f9078257d11, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f9084fd6179, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f9091d545e1, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f909eac43cf, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90ab842837, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90b85c0c9f, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90c533f107, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90d20bd56f, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...

 *** caught bus error ***
address 0x7f90f89382a7, cause 'non-existent physical address'

Traceback:
 1: .Call("BEDMatrixPlus__multiply_residuals", x@xptr, js, je, missing,     residuals, PACKAGE = "snpnet")
 2: multiply_residuals.BEDMatrixPlus(X, path, taskIndex[1, whichTask],     taskIndex[2, whichTask], missing, residuals)
 3: multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,     whichTask], missing, residuals)
 4: FUN(X[[i]], ...)
 5: eval(expr, env)
 6: doTryCatch(return(expr), name, parentenv, handler)
 7: tryCatchOne(expr, names, parentenv, handlers[[1L]])
 8: tryCatchList(expr, classes, parentenv, handlers)
 9: tryCatch(expr, error = function(e) {    call <- conditionCall(e)    if (!is.null(call)) {        if (identical(call[[1L]], quote(doTryCatch)))             call <- sys.call(-4L)        dcall <- deparse(call)[1L]        prefix <- paste("Error in", dcall, ": ")        LONG <- 75L        sm <- strsplit(conditionMessage(e), "\n")[[1L]]        w <- 14L + nchar(dcall, type = "w") + nchar(sm[1L], type = "w")        if (is.na(w))             w <- 14L + nchar(dcall, type = "b") + nchar(sm[1L],                 type = "b")        if (w > LONG)             prefix <- paste0(prefix, "\n  ")    }    else prefix <- "Error : "    msg <- paste0(prefix, conditionMessage(e), "\n")    .Internal(seterrmessage(msg[1L]))    if (!silent && isTRUE(getOption("show.error.messages"))) {        cat(msg, file = outFile)        .Internal(printDeferredWarnings())    }    invisible(structure(msg, class = "try-error", condition = e))})
10: try(eval(expr, env), silent = TRUE)
11: sendMaster(try(eval(expr, env), silent = TRUE))
12: mcparallel(FUN(X[[i]], ...), name = names(X)[i], mc.set.seed = mc.set.seed,     silent = mc.silent)
13: FUN(X[[i]], ...)
14: lapply(seq_along(X), function(i) mcparallel(FUN(X[[i]], ...),     name = names(X)[i], mc.set.seed = mc.set.seed, silent = mc.silent))
15: parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,     ...) {    multiply_residuals(X, path, taskIndex[1, whichTask], taskIndex[2,         whichTask], missing, residuals)}, ..., mc.preschedule = FALSE, mc.cores = nCores)
16: FUN(X[[i]], ...)
17: lapply(seq_len(nBuffers), function(whichBuffer) {    if (verbose) {        message("Buffer ", whichBuffer, " of ", nBuffers, " ...")    }    if (nTasks == 1L) {        multiply_residuals(X, path, bufferRanges[1L, whichBuffer],             bufferRanges[2L, whichBuffer], missing, residuals)    }    else {        bufferIndex <- bufferRanges[, whichBuffer]        taskIndex <- chunkRanges(bufferIndex[2] - bufferIndex[1] +             1, nTasks) + bufferIndex[1] - 1        res <- parallel::mclapply(X = seq_len(nTasks), FUN = function(whichTask,             ...) {            multiply_residuals(X, path, taskIndex[1, whichTask],                 taskIndex[2, whichTask], missing, residuals)        }, ..., mc.preschedule = FALSE, mc.cores = nCores)        simplifyList_Col(res)    }})
18: chunkedApply_missing(chr, residual.full, missing = stats[["means"]],     nCores = configs[["nCores"]], bufferSize = configs[["bufferSize"]],     verbose = verbose, path = path)
19: computeProduct(residual, chr, subset, stats, configs, verbose,     path = path)
20: KKT.check(residual.full, chr.train, rowIdx.subset.train, current.lams[start.lams:num.lams],     ifelse(use.glmnetPlus, 1, lambda.idx), stats, glmfit, configs,     buffer.verbose, KKT.verbose, path = file.path(genotype.dir,         "train.bed"))
21: snpnet(genotype.dir = config[["genotype_dir"]], phenotype.file = phenotype.file,     phenotype = phenotype.name, covariates = covariates, family = config[["family"]],     results.dir = results.dir, niter = as.integer(config[["niter"]]),     configs = list(missing.rate = 0.1, MAF.thresh = 0.001, nCores = as.integer(config[["cpu"]]),         bufferSize = as.integer(as.integer(config[["mem"]])/as.integer(config[["mem2bufferSizeDivisionFactor"]])),         meta.dir = "meta", nlams.init = 10, nlams.delta = 5),     verbose = T, validation = T, save = T, prevIter = as.integer(config[["prevIter"]]))
An irrecoverable exception occurred. R is aborting now ...
Error in dimnames(x) <- dn : 
  length of 'dimnames' [1] not equal to array extent
Calls: snpnet -> KKT.check -> computeProduct -> rownames<-
In addition: There were 20 warnings (use warnings() to see them)
Execution halted
